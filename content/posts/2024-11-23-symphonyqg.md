---
author: "Chao.G"
title: "SymphonyQG: Symphonious Integration of Quantization and Graph"
date: "2024-11-23"
markup: "mmark"
draft: false
tags: ["ann"]
categories: ["Papers"]
---

这是一篇已经被SIGMOD2025录用的[论文](https://arxiv.org/pdf/2411.12229)，也是上一次[分享](https://zhuanlan.zhihu.com/p/7193968541)的后续工作，还是很佩服这种可以自己挖坑然后持续扩展的工作的。这篇文章简单来说就是解决上一篇论文RabitQ如何集成到图索引的问题，也就是名字SymphonyQG的由来吧，与上一篇文章的区别在于这篇文章非常地偏工程，读下来会觉得更加易懂，而且我觉得也是近期比较少见的在“卷”索引性能的工作了。最近的很多论文大部分还是以某个小点的算法优化为切入点，其实和实际生产中的索引性能还是存在着一些gap。

## 背景

首先可以简单说[NGT-QG](https://github.com/yahoojapan/NGT)这个工作，就是量化和图索引结合的例子，因为ScaNN或者说FastScan的SIMD优势在于batch计算量化，而这个模式天然和图索引有一些冲突，因为图索引的计算模式是单条向量的距离计算，比较适用于IVF的计算模式。NGT-QG把量化code一同保存在图的邻居中，对这一批的邻居使用SIMD高效计算量化距离，达到很不错的性能。

而本文提出了一些优化的点，首先基于自己之前的工作[RabitQ](https://arxiv.org/pdf/2405.12497)，由于RabitQ本身的量化精度会比PQ要好，但是集成RabitQ到图索引中需要一定的改造，同时需要对查询算法做一些调整。由于NGT-QG并不保证图的邻居数是满的，而量化SIMD的计算是batch模式，这会导致计算的浪费，尽可能地让图的邻居填满充分参与计算的结果。最后查询算法还可以用于加速索引的构建。

## Query Phase

### 集成RabitQ到图索引

首先RabitQ的问题是需要把base向量归一化，而IVF索引会有聚类中心，所以基于聚类中心做归一化就比较简单。但是在图索引中，这个聚类中心就不存在了，当然这里可以有个问题是能否可以使用一个统一的聚类中心呢，但相信这一定会让精度受到影响。但是论文中找到了图索引中天然的参照点，某个点的邻居就都可以基于该点来做归一化。但是会带来查询的问题，计算的目标是$<\bar{x}, P^{-1}q>, q = \frac{q_r - c}{||q_r - c||}$，而现在每个点都会成为$c$用于它邻居点的计算，需要构建特别多的Lookup table。但是可以简单地调整计算的方式来解决这个问题，$<\bar{x}, P^{-1}q>=<\bar{x}, P^{-1}\frac{q_r - c}{||q_r - c||}> = \frac{1}{||q_r - c||} \cdot (<\bar{x}, P^{-1}q_r> - <\bar{x}, P^{-1}c>)$，运行时考虑$<\bar{x}, P^{-1}q_r>$即可。

### 避免显式的re-ranking过程

在NGT-QG中，图搜的过程中使用PQ距离，最后使用re-ranking的过程来提高精度，这个步骤会有随机的内存访问，也有可能成为一个较耗时的部分。本文采取了一个类似于DiskANN的方式来进行边搜边re-ranking的过程，在图搜的过程中，会维护两个队列，一个队列用于导航，每次pop出来最近的点作为搜索需要扩展的点，另一个队列用于保存结果。每次从导航队列里找到最近的点，计算出真实距离放入结果队列，这时候才认为这个点是被"visited"的，然后找到该点的邻居计算量化距离更新导航队列。所以导航队列里保存的是量化距离，而结果队列里保存的是精确距离。这个改动我觉得有一个很重要的原因是要使用SIMD批量计算邻居的量化距离，所以所有的点都会参与到计算，即便这里会有对同一个点重复的计算，由于上一章节的设定也可能是不同的量化距离，所以仍然是有意义的。


![storage](/assets/sym-storage.png)

## Index Phase

构建索引的阶段，可以用搜索的算法来构建图，加速构建效率。另外一点就是把图的出度尽可能填满，其实这个点也是比较简单的，选出某个点的candidates以后进行剪枝得到最后的邻居，而可以适当放宽这个剪枝条件使得图的出度被填满，可以被用到搜索过程中，这不会增加计算的开销，而让更多的点被考虑进来了，肯定对于搜索是有利的。

但是在内存占用上，因为每个点的邻居都需要同时存一份量化code，这会导致内存几乎double甚至更多，这个问题几乎就是这个算法最大的缺陷。

## 实验

实验部分就是非常直接的性能碾压，并且在这里也验证了前面的说法，就是很多算法论文并不能真正地体现出优越的性能，所以这里也对比了一些工业界的方案。

![exp](/assets/sym-exp.png)


## 一点想法

这个工作比较棘手的问题便是内存的大幅上涨，也是作者在最后列出的future work，是否可以利用一些降维的手段减少内存。

还有一点是关于写论文的事情，其实这篇论文本身的点还是比较intuitive的，比较像是偏工程的文章。如何去评判一个工作是否可以成文，这是一个挺有意思的事情，其实NGT-QG这个工作也是有机会发表在顶会上的，即使把量化和图结合的idea比较trivial，但是多想一些点，做一些充分的实验还是很有机会的。

## Reference

- https://github.com/yahoojapan/NGT
- https://zhuanlan.zhihu.com/p/7193968541
- https://arxiv.org/pdf/2411.12229
- https://arxiv.org/pdf/2405.12497
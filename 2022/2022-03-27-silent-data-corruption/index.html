<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta name=author content="Chao.G"><meta name=description content="高超的个人博客"><link rel=prev href=https://chasingegg.github.io/2022/2022-02-15-ann-early-termination/><link rel=canonical href=https://chasingegg.github.io/2022/2022-03-27-silent-data-corruption/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><title>静默数据损坏 | Chao.G</title><meta name=title content="静默数据损坏 | Chao.G"><link rel=stylesheet href=/css/main.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/chasingegg.github.io"},"articleSection":"posts","name":"静默数据损坏","headline":"静默数据损坏","description":"对于大部分开发人员来说，数据的可靠性，一致性等要求都是逻辑层面上的东西，比如数据库系统中的事务，保证银行里的钱不会出错。但是从存储系统的角度","inLanguage":"zh-cn","author":"Chao.G","creator":"Chao.G","publisher":"Chao.G","accountablePerson":"Chao.G","copyrightHolder":"Chao.G","copyrightYear":"2022","datePublished":"2022-03-27 00:00:00 \u002b0000 UTC","dateModified":"2022-03-27 00:00:00 \u002b0000 UTC","url":"https:\/\/chasingegg.github.io\/2022\/2022-03-27-silent-data-corruption\/","wordCount":"1269","keywords":["data center","Chao.G"]}</script></head><body><div class=wrapper><nav class=navbar><progress class=content_progress max=0 value=0></progress><div class=container><div class="navbar-header header-back2home-logo"><span class=logo_mark>>$</span>
<a href=https://chasingegg.github.io><span class=logo_text>cd /home/</span>
<span class=logo_cursor></span></a></div><div class=navbar-right><span class=menu><a class=menu-item href=/posts/ title>Blog</a>
<a class=menu-item href=/categories/ title>Categories</a>
<a class=menu-item href=/tags/ title>Tags</a>
<a class=menu-item href=/about/ title>About</a>
<span class=divide></span><a href=javascript:void(0); class=theme-switch><i class="iconfont icon-dark-mode"></i></a></span></div></div></nav><nav class=navbar-mobile id=nav-mobile style=display:none><progress class=content_progress max=0 value=0></progress><div class=container><div class=navbar><div class="navbar-header header-logo"><a href=https://chasingegg.github.io>Chao.G</a></div><div class=navbar-right><div><a href=javascript:void(0); class=theme-switch><i class="iconfont icon-dark-mode"></i></a></div><div class=menu-toggle><span></span><span></span><span></span></div></div></div><div class=menu id=mobile-menu><nav class=mb-md><a class=menu-item href=/posts/ title><h3>Blog</h3><div class=menu-active></div></a><a class=menu-item href=/categories/ title><h3>Categories</h3><div class=menu-active></div></a><a class=menu-item href=/tags/ title><h3>Tags</h3><div class=menu-active></div></a><a class=menu-item href=/about/ title><h3>About</h3><div class=menu-active></div></a></nav></div></div></nav><main class=main><div class=container><article class=post-warp itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline">静默数据损坏</h1><div class=post-meta>Written by <a itemprop=name href=https://chasingegg.github.io rel=author>Chao.G</a> with ♥
<span class=post-time>on <time datetime=2022-03-27 itemprop=datePublished>March 27, 2022</time></span>
in
<i class="iconfont icon-folder"></i><span class=post-category><a href=https://chasingegg.github.io/categories/share/>Share,</a></span>
<span class=post-word-count>1269 words</span></div></header><div class=post-content><p>对于大部分开发人员来说，数据的可靠性，一致性等要求都是逻辑层面上的东西，比如数据库系统中的事务，保证银行里的钱不会出错。但是从存储系统的角度来看，即使我们用各种算法保证了逻辑层面的正确性，真实系统仍然可能因为各种硬件故障导致数据缺失或者出现错误。而静默数据损坏（Silent Data Corruption，记作SDC）是一个很危险的事情，说明这些错误没有通过CPU错误报告机制捕获，无法第一时间显示地被发现，直到应用程序使用数据时才会被发现问题。</p><p>对于大公司的infra团队而言，SDC并不罕见，Facebook对这个问题也有一些处理的方法并做了详细的case study，本文简要地做下介绍。</p><h2 id=背景>背景</h2><p>静默数据损坏有些是偶发性的，受到一些射线影响或者环境因素造成位翻转，这些可以用纠错码技术较好地解决。但是有些静默数据损坏是可以复现的，比如CPU计算2x3的结果是5，而不是6。而且随着CPU芯片不断提升的硅密度，架构设计复杂性的不断增加，这个问题需要引起更大的重视。</p><h2 id=问题>问题</h2><p>作为互联网巨头Facebook，发现了不少SDC问题，并对这个问题进行一段时间的监控，给出了一些解决方案缓解数据损坏的风险。</p><p>比如在Facebook内部，由Spark支撑的分布式数据查询服务，用户每天会在这个查询服务上运行上百万个ETL任务，其中会计算出被压缩后的文件大小，把计算后的数据压缩存在分布式文件系统之上。但是SDC发生的时候，可能这个计算结果变成了0，结果就是这个文件没有写出去，最终表现就是一个数据集里面缺了部分数据，那么下游数据查询的时候就会发生数据丢失。但显然这样的问题非常难排查。</p><h2 id=排查>排查</h2><p>首先对所有集群机器加上一些日志，最终将范围缩小到一台机器上，在这台机器上可以发现这个问题也是偶发的。最终可以定位到是一个cpu核上对应特定的数据会有可以持续复现的错误。具体到这个case，由于Scala和C/C++不同，它是JIT编译成java字节码跑在JVM上的，不是提前编译好的，就不能拿到机器码指令，需要有一个probe程序可以帮助我们知道实际执行的指令。幸运的是，我们可以加上一个<code>+printAssembly</code>的选项，就可以打印出执行的字节码。</p><p>在拿到机器码以后的排查思路，论文给出了一些最佳实践比如绝对地址的引用，外部库调用，编译器优化等。定位到最小的一个代码块，比如在Facebook的这个例子里就是一个scala的math.pow函数。下面是一个排查的工作流。</p><p><img src=/assets/debug-flow.png alt=image-20220327220048044 style=zoom:50%></p><h2 id=思考>思考</h2><p>CPU是计算机的大脑，我们总是习惯了CPU是永远不会出错的，但CPU毕竟也是人造出来的工业品，必然会出错。而静默数据损坏确实是一个难以解决的问题，首先定位问题就是一件非常困难的事，平常我们遇到问题的时候必然不会考虑到这个方面，但是对于一个大型的数据中心而言，这出错的机会就大大增加了。似乎没有一个根本解决的方法，毕竟只要是硬件一定会出问题，对于使用方来说建立一个比较完善的监控（面向应用的高效检测），容错机制（快速下线问题机器，在新的机器上重新运行任务）以及问题排查流程（论文里提供的一套方法总结）。</p><h2 id=reference>Reference</h2><ul><li><a href=https://developer.aliyun.com/article/785000>https://developer.aliyun.com/article/785000</a></li><li><a href=https://arxiv.org/pdf/2102.11245.pdf>https://arxiv.org/pdf/2102.11245.pdf</a></li></ul></div><div class=post-copyright><p class=copyright-item><span>Author:</span>
<span>Chao.G</span></p><p class="copyright-item lincese">本文采用<a rel=license href=http://creativecommons.org/licenses/by-nc/4.0/ target=_blank>知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p></div><div class=post-tags><section><i class="iconfont icon-tag"></i>Tag(s):
<span class=tag><a href=https://chasingegg.github.io/tags/data-center/>#data center</a></span></section><section><a href=javascript:window.history.back();>back</a></span> ·
<span><a href=https://chasingegg.github.io>home</a></span></section></div><div class=post-nav><a href=https://chasingegg.github.io/2022/2022-02-15-ann-early-termination/ class=prev rel=prev title="Improving anns through learned adaptive early termination"><i class="iconfont icon-left"></i>&nbsp;Improving anns through learned adaptive early termination</a></div><div class=post-comment><div id=utteranc-container><script src=https://utteranc.es/client.js repo=chasingegg/chasingegg.github.io issue-term=title theme=preferred-color-scheme crossorigin=anonymous async></script></div></div></article></div></main><footer class=footer><div class=copyright>&copy;
<span itemprop=copyrightYear>2021 - 2022</span>
<span class=with-love><i class="iconfont icon-love"></i></span><span class=author itemprop=copyrightHolder><a href=https://chasingegg.github.io>Chao.G</a> |</span>
<span>Powered by <a href=https://gohugo.io/ target=_blank rel="external nofollow">Hugo</a> & <a href=https://github.com/Mogeko/Mogege target=_blank rel="external nofollow">Mogege</a></span></div></footer><script defer src=/js/vendor_main.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css integrity="sha256-V8SV2MO1FUb63Bwht5Wx9x6PVHNa02gv8BgH/uH3ung=" crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js integrity="sha256-F/Xda58SPdcUCr+xhSGz9MA2zQBPb0ASEYKohl8UCHc=" crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js integrity="sha256-90d2pnfw0r4K8CZAWPko4rpFXQsZvJhTBGYNkipDprI=" crossorigin=anonymous onload=renderMathInElement(document.body)></script><script src=https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin=anonymous></script><script>pangu.spacingPage()</script></div></body></html>